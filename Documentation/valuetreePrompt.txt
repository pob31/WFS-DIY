Prompt for Claude Code - ValueTree Parameter System with Save/Recall
I need you to implement a complete ValueTree-based parameter system for this WFS (Wave Field Synthesis) processor application. The parameter definitions are in the CSV files in this project.
Core Requirements:

Parse the CSV specification files to extract all parameters:

WFS-UI_config.csv - System configuration parameters
WFS-UI_input.csv - Per-input channel parameters (up to 64 channels)
WFS-UI_output.csv - Per-output channel parameters (up to 64 channels)
WFS-UI_AudioPatch.csv - Audio routing parameters


Create a hierarchical ValueTree structure:

WFSProcessor (root)
├── Config
│   ├── Show (showName, showLocation)
│   ├── IO (inputChannels, outputChannels, reverbChannels, runDSP)
│   ├── Stage (stageWidth, stageDepth, stageHeight, originWidth, originDepth, originHeight, speedOfSound, temperature)
│   ├── Master (masterLevel, systemLatency, haasEffect)
│   ├── Network
│   │   ├── Settings (networkCurrentIP, networkRxUDPport, networkRxTCPport)
│   │   └── Targets (array of up to 6 NetworkTarget nodes)
│   ├── ADMOSC (offsets, scales, flips)
│   └── Tracking (enabled, protocol, port, offsets, scales, flips)
├── Inputs (array of Input nodes, one per channel)
│   └── Input (id="1")
│       ├── Channel (name, attenuation, delayLatency, minimalLatency)
│       ├── Position (x, y, z, offsets, constraints, flips, cluster, tracking)
│       ├── Attenuation (law, distanceAttenuation, distanceRatio, commonAtten)
│       ├── Brightness (law, angle, rotation)
│       ├── Reverb (sends array)
│       ├── LFO (active, frequency, shape, amplitude, phase, gyrophone per axis)
│       ├── AutomOtion (destination, mode, speed, trigger settings)
│       └── Mutes (array of per-output mutes)
├── Outputs (array of Output nodes, one per channel)
│   └── Output (id="1")
│       ├── Channel (name, array, applyToArray, attenuation, delayLatency)
│       ├── Position (x, y, z, orientation, angleOn, angleOff, pitch, HFdamping)
│       ├── Options (miniLatencyEnable, LSenable, distanceAttenPercent, parallax)
│       └── EQ (enabled, 6 bands with shape, frequency, gain, Q, slope each)
└── AudioPatch
    ├── Settings (driverMode, audioInterface)
    ├── InputPatch (2D matrix array)
    └── OutputPatch (2D matrix array)

Implement with JUCE best practices:

cpp// Required classes to create:

// WFSParameterIDs.h - String identifiers for all parameters
namespace WFSParameterIDs
{
    // Use the Variable names from CSV files as identifiers
    const juce::Identifier showName ("showName");
    const juce::Identifier showLocation ("showLocation");
    // ... all parameters from CSVs
}

// WFSValueTreeState.h/.cpp - Main parameter management class
class WFSValueTreeState : public juce::ValueTree::Listener
{
public:
    WFSValueTreeState();
    
    // Access methods
    juce::ValueTree getState() { return state; }
    juce::ValueTree getConfigState();
    juce::ValueTree getInputState (int channelIndex);
    juce::ValueTree getOutputState (int channelIndex);
    
    // Parameter access with type safety
    float getFloatParameter (const juce::Identifier& id, int channelIndex = -1);
    int getIntParameter (const juce::Identifier& id, int channelIndex = -1);
    juce::String getStringParameter (const juce::Identifier& id, int channelIndex = -1);
    
    void setParameter (const juce::Identifier& id, const juce::var& value, int channelIndex = -1);
    
    // Undo/Redo
    juce::UndoManager* getUndoManager() { return &undoManager; }
    void undo() { undoManager.undo(); }
    void redo() { undoManager.redo(); }
    
    // Save/Load
    bool saveToFile (const juce::File& file);
    bool loadFromFile (const juce::File& file);
    bool saveBackup (const juce::File& originalFile);
    
    // Listener registration for UI components
    void addParameterListener (const juce::Identifier& id, std::function<void(const juce::var&)> callback);
    
private:
    juce::ValueTree state;
    juce::UndoManager undoManager;
    
    void initializeDefaultState();
    void createDefaultInputChannel (int index);
    void createDefaultOutputChannel (int index);
};

Human-readable XML file format:

The saved XML must be easy to read and edit manually. Example output:
xml<?xml version="1.0" encoding="UTF-8"?>
<WFSProcessor version="1.0">
  
  <Config>
    <Show name="Festival Geneva 2025" location="Victoria Hall"/>
    
    <IO inputChannels="24" outputChannels="32" reverbChannels="6" runDSP="0"/>
    
    <Stage width="20.0" depth="10.0" height="8.0"
           originWidth="10.0" originDepth="0.0" originHeight="0.0"
           speedOfSound="343.0" temperature="20.0"/>
    
    <Master level="0.0" systemLatency="0.0" haasEffect="0.1"/>
    
    <Network currentIP="192.168.1.100" rxUDPport="8000" rxTCPport="8001">
      <Target id="1" name="Console" mode="UDP" ip="192.168.1.50" port="9000" 
              rxEnable="1" txEnable="1" protocol="OSC"/>
      <Target id="2" name="Remote" mode="TCP" ip="192.168.1.60" port="9001"
              rxEnable="1" txEnable="0" protocol="REMOTE"/>
    </Network>
    
    <ADMOSC offsetX="0.0" offsetY="0.0" offsetZ="0.0"
            scaleX="1.0" scaleY="1.0" scaleZ="1.0"
            flipX="0" flipY="0" flipZ="0"/>
    
    <Tracking enabled="0" protocol="OSC" port="7000"
              offsetX="0.0" offsetY="0.0" offsetZ="0.0"
              scaleX="1.0" scaleY="1.0" scaleZ="1.0"
              flipX="0" flipY="0" flipZ="0"/>
  </Config>
  
  <Inputs count="24">
    <Input id="1" name="Violin 1">
      <Channel attenuation="-6.0" delayLatency="0.0" minimalLatency="0"/>
      <Position x="2.5" y="3.0" z="0.0"
                offsetX="0.0" offsetY="0.0" offsetZ="0.0"
                constraintX="1" constraintY="1" constraintZ="1"
                flipX="0" flipY="0" flipZ="0"
                cluster="0" trackingActive="0" trackingID="1" trackingSmooth="100"/>
      <Attenuation law="0" distance="-0.7" ratio="1.0" common="100"/>
      <Brightness law="0" angle="180" rotation="0"/>
      <Reverb send1="0.0" send2="0.0" send3="0.0" send4="0.0" send5="0.0" send6="0.0"/>
      <LFO active="0" frequency="1.0"
           shapeX="0" amplitudeX="1.0" phaseX="0"
           shapeY="0" amplitudeY="1.0" phaseY="0"
           shapeZ="0" amplitudeZ="1.0" phaseZ="0"
           gyrophone="0"/>
      <AutomOtion destX="0.0" destY="0.0" destZ="0.0"
                  absolute="0" stayReturn="0" speedProfile="0"
                  trigger="0" threshold="-20.0" reset="-60.0"/>
      <Mutes>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</Mutes>
    </Input>
    
    <Input id="2" name="Violin 2">
      <!-- ... -->
    </Input>
    <!-- ... remaining inputs -->
  </Inputs>
  
  <Outputs count="32">
    <Output id="1" name="Array1-L1" array="1">
      <Channel attenuation="0.0" delayLatency="0.0" applyToArray="1"/>
      <Position x="-8.0" y="6.0" z="2.5"
                orientation="15" angleOn="86" angleOff="90" pitch="0"
                HFdamping="0.0"/>
      <Options miniLatencyEnable="1" LSattenEnable="1" 
               distanceAttenPercent="100"
               Hparallax="0.0" Vparallax="0.0"/>
      <EQ enabled="1">
        <Band id="1" shape="1" frequency="80" gain="0.0" Q="0.7" slope="0.7"/>
        <Band id="2" shape="3" frequency="250" gain="-2.0" Q="1.5" slope="0.7"/>
        <Band id="3" shape="3" frequency="1000" gain="0.0" Q="0.7" slope="0.7"/>
        <Band id="4" shape="3" frequency="4000" gain="0.0" Q="0.7" slope="0.7"/>
        <Band id="5" shape="5" frequency="8000" gain="0.0" Q="0.7" slope="0.7"/>
        <Band id="6" shape="0" frequency="12000" gain="0.0" Q="0.7" slope="0.7"/>
      </EQ>
    </Output>
    <!-- ... remaining outputs -->
  </Outputs>
  
  <AudioPatch driverMode="0" audioInterface="RME Fireface UCX II">
    <InputPatch rows="24" cols="64">
      1,0,0,0,0,0,0,0,...
      0,1,0,0,0,0,0,0,...
      <!-- 1:1 diagonal mapping by default -->
    </InputPatch>
    <OutputPatch rows="32" cols="64">
      1,0,0,0,0,0,0,0,...
      0,1,0,0,0,0,0,0,...
    </OutputPatch>
  </AudioPatch>
  
</WFSProcessor>

Save/Load Implementation:

cpp// Save with automatic backup
bool WFSValueTreeState::saveToFile (const juce::File& file)
{
    // Create backup of existing file first
    if (file.existsAsFile())
        saveBackup (file);
    
    // Create XML with human-readable formatting
    auto xml = state.createXml();
    if (xml == nullptr)
        return false;
    
    // Write with proper indentation for readability
    return xml->writeTo (file, juce::XmlElement::TextFormat()
        .withoutHeader()  // We'll add our own header
        .singleLine (false));
}

// Load with validation
bool WFSValueTreeState::loadFromFile (const juce::File& file)
{
    auto xml = juce::XmlDocument::parse (file);
    if (xml == nullptr)
        return false;
    
    auto newState = juce::ValueTree::fromXml (*xml);
    if (!newState.isValid())
        return false;
    
    // Validate structure before replacing
    if (!validateState (newState))
        return false;
    
    // Use UndoManager for the replacement so it can be undone
    state.copyPropertiesAndChildrenFrom (newState, &undoManager);
    return true;
}

// Backup creates timestamped copy
bool WFSValueTreeState::saveBackup (const juce::File& originalFile)
{
    auto backupDir = originalFile.getParentDirectory().getChildFile ("backups");
    backupDir.createDirectory();
    
    auto timestamp = juce::Time::getCurrentTime().formatted ("%Y%m%d_%H%M%S");
    auto backupFile = backupDir.getChildFile (
        originalFile.getFileNameWithoutExtension() + "_" + timestamp + ".xml");
    
    return originalFile.copyFileTo (backupFile);
}

Undo/Redo Integration:

cpp// All parameter changes go through UndoManager
void WFSValueTreeState::setParameter (const juce::Identifier& id, 
                                       const juce::var& value, 
                                       int channelIndex)
{
    auto tree = getTreeForParameter (id, channelIndex);
    if (tree.isValid())
    {
        tree.setProperty (id, value, &undoManager);
    }
}

// Batch changes for complex operations (e.g., loading a snapshot)
void WFSValueTreeState::beginUndoTransaction (const juce::String& name)
{
    undoManager.beginNewTransaction (name);
}

// Group multiple changes as single undo step
void WFSValueTreeState::loadInputSnapshot (const juce::File& snapshotFile)
{
    beginUndoTransaction ("Load Input Snapshot");
    // ... apply all snapshot values ...
    // User can undo entire snapshot load with single Ctrl+Z
}

Parameter Listener System for UI Updates:

cpp// UI components register for specific parameter changes
class WFSValueTreeState::ParameterListener : public juce::ValueTree::Listener
{
public:
    void valueTreePropertyChanged (juce::ValueTree& tree, 
                                   const juce::Identifier& property) override
    {
        // Notify registered callbacks
        if (auto* callback = callbacks.find (property))
            (*callback) (tree.getProperty (property));
    }
    
private:
    std::map<juce::Identifier, std::function<void(const juce::var&)>> callbacks;
};

// Usage in UI component:
valueTreeState.addParameterListener (WFSParameterIDs::inputAttenuation, 
    [this] (const juce::var& value) 
    {
        attenuationSlider.setValue (static_cast<float> (value), 
                                    juce::dontSendNotification);
    });
```

8. **Default Values from CSV:**

Extract default values from the CSV "Default" column:
- Use these when creating new channels
- Use these for "Reset to Default" functionality
- Validate loaded files against expected ranges (Min/Max columns)

9. **File Types to Support:**

Based on the Store/Reload sections in the CSVs, implement:
- **Complete Configuration** - Entire WFSProcessor state
- **System Configuration** - Config section only (includes audio patch)
- **Input Configuration** - All input channels
- **Output Configuration** - All output channels  
- **Input Snapshots** - Named snapshots of input states with scope selection

10. **Project Folder Structure:**
```
ProjectFolder/
├── show.wfs              (Complete configuration)
├── system.wfs            (System configuration)
├── inputs.wfs            (Input configuration)
├── outputs.wfs           (Output configuration)
├── snapshots/
│   ├── inputs/
│   │   ├── scene1.snap
│   │   └── scene2.snap
│   └── outputs/
├── backups/
│   ├── show_20251210_143022.wfs
│   └── show_20251210_151544.wfs
└── audio_patch.wfs       (Audio routing)
```

**Code Organization:**
```
Source/
├── Parameters/
│   ├── WFSParameterIDs.h          // All parameter identifiers
│   ├── WFSValueTreeState.h/.cpp   // Main parameter management
│   ├── WFSParameterDefaults.h     // Default values from CSV
│   └── WFSFileManager.h/.cpp      // Save/Load/Backup operations
Testing:
After implementation:

Create a default state and save to file - verify XML is readable
Edit XML manually, load it back - verify changes applied
Make changes, undo/redo - verify state reverts correctly
Save, modify, save again - verify backup was created
Load corrupted/invalid file - verify graceful error handling